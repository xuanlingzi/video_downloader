#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Video Downloader API
~~~~~~~~~~~~~~~~~~

一个基于 Flask 的视频下载 API 服务，支持从多个平台下载视频和音频。

主要功能:
- 支持视频和音频下载
- 自动文件清理
- 文件名规范化
- 定时任务调度
- 支持自定义CA证书

使用方法:
    $ python app.py

环境变量:
    DOWNLOAD_DIR: 下载目录路径（可选，默认使用临时目录）
    PORT: 服务端口（可选，默认 8000）
    CLEANUP_INTERVAL_HOURS: 文件清理间隔（可选，默认 24 小时）
    CA_CERT_PATH: CA证书路径（可选，用于处理MITM代理）
"""

import os
import re
import glob
import hashlib
import logging
import tempfile
from typing import Optional, Dict, Any, List
from datetime import datetime, timedelta
import yaml
from urllib.parse import urlparse
import urllib.parse

from flask import Flask, request, jsonify, send_file, Response
import yt_dlp
from apscheduler.schedulers.background import BackgroundScheduler

# 配置常量
DEFAULT_PORT = 8080
DEFAULT_CLEANUP_INTERVAL_HOURS = 24
DEFAULT_MAX_FILENAME_LENGTH = 100
DEFAULT_DOWNLOAD_DIR = "downloads"
COOKIES_DIR = os.path.join(os.path.dirname(__file__), 'cookies')

# 日志配置
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# 初始化 Flask 应用
app = Flask(__name__)


# 加载配置文件
def load_config() -> Dict[str, Any]:
    config_path = os.path.join(os.path.dirname(__file__), 'config.yaml')
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except Exception as e:
        logger.error(f"加载配置文件失败: {e}")
        return {}


CONFIG = load_config()
DOWNLOAD_DIR = CONFIG.get('app', {}).get('output_dir', DEFAULT_DOWNLOAD_DIR)
PORT = CONFIG.get('app', {}).get('port', DEFAULT_PORT)
CLEANUP_INTERVAL_HOURS = CONFIG.get('app',
                                    {}).get('cleanup_interval_hours',
                                            DEFAULT_CLEANUP_INTERVAL_HOURS)
# 确保下载目录存在
os.makedirs(DOWNLOAD_DIR, exist_ok=True)


class DownloadError(Exception):
    """下载过程中的自定义异常"""
    pass


def ensure_download_dir() -> None:
    """确保下载目录存在"""
    if not os.path.exists(DOWNLOAD_DIR):
        os.makedirs(DOWNLOAD_DIR)
        logger.info(f"创建下载目录: {DOWNLOAD_DIR}")


def sanitize_filename(filename: str,
                      max_length: int = DEFAULT_MAX_FILENAME_LENGTH) -> str:
    """
    清理并规范化文件名。

    Args:
        filename: 原始文件名
        max_length: 最大文件名长度

    Returns:
        str: 处理后的文件名
    """
    # 移除不安全的字符
    filename = re.sub(r'[^\w\s-]', '', filename)
    # 将空格替换为下划线
    filename = re.sub(r'\s+', '_', filename)
    # 限制文件名长度
    if len(filename) > max_length:
        name, ext = os.path.splitext(filename)
        filename = name[:max_length - len(ext)] + ext
    return filename


def create_cookie_file(domain: str, cookies_str: str) -> str:
    """
    创建 Netscape 格式的 cookie 文件
    
    Args:
        domain: 实际域名
        cookies_str: cookie 字符串，格式如 "name1=value1; name2=value2"
    Returns:
        str: cookie 文件路径
    """
    cookie_file = os.path.join(COOKIES_DIR, f'{domain}.txt')

    with open(cookie_file, 'w', encoding='utf-8') as f:
        f.write('# Netscape HTTP Cookie File\n')
        f.write('# https://curl.haxx.se/rfc/cookie_spec.html\n')
        f.write('# This file was generated by video_downloader\n\n')

        # 解析 cookie 字符串
        for cookie in cookies_str.split(';'):
            cookie = cookie.strip()
            if not cookie:
                continue
            try:
                name, value = cookie.split('=', 1)
                # Netscape cookie 格式：
                # domain flag path secure expiry name value
                f.write(
                    f'.{domain}\tTRUE\t/\tFALSE\t0\t{name.strip()}\t{value.strip()}\n'
                )
            except ValueError:
                logger.warning(f"跳过无效的 cookie: {cookie}")

    return cookie_file


def init_cookie_files() -> None:
    """初始化所有网站的 cookie 文件"""
    try:
        # 确保 cookies 目录存在
        os.makedirs(COOKIES_DIR, exist_ok=True)

        # 清理旧的 cookie 文件
        for file in os.listdir(COOKIES_DIR):
            try:
                os.remove(os.path.join(COOKIES_DIR, file))
            except OSError as e:
                logger.error(f"删除旧的 cookie 文件失败: {e}")

        # 为每个网站创建 cookie 文件
        for site_name, site_config in CONFIG.get('sites', {}).items():
            cookies_str = site_config.get('cookies')
            if not cookies_str:
                continue

            # 为每个域名创建 cookie 文件
            for domain in site_config.get('domains', []):
                try:
                    create_cookie_file(domain, cookies_str)
                    logger.info(f"已创建 {domain} 的 cookie 文件")
                except Exception as e:
                    logger.error(f"创建 {domain} 的 cookie 文件失败: {e}")

    except Exception as e:
        logger.error(f"初始化 cookie 文件失败: {e}")


def get_site_cookies(url: str) -> Optional[str]:
    """
    根据URL获取对应网站的cookie文件路径
    
    Args:
        url: 视频URL
        
    Returns:
        Optional[str]: cookie 文件路径，如果没有配置则返回 None
    """
    domain = urlparse(url).netloc

    # 遍历所有网站配置
    for site_name, site_config in CONFIG.get('sites', {}).items():
        # 检查域名是否匹配该网站的任一域名
        if any(d.lower() in domain.lower()
               for d in site_config.get('domains', [])):
            cookie_file = os.path.join(COOKIES_DIR, f'{domain}.txt')
            if os.path.exists(cookie_file):
                return cookie_file
            break

    return None


def cleanup_downloads() -> None:
    """清理过期的下载文件"""
    try:
        logger.info("开始清理下载目录...")
        now = datetime.now()
        count = 0

        # 清理下载文件
        for item in os.listdir(DOWNLOAD_DIR):
            item_path = os.path.join(DOWNLOAD_DIR, item)
            if not os.path.isfile(item_path):
                continue

            file_mtime = datetime.fromtimestamp(os.path.getmtime(item_path))
            if now - file_mtime > timedelta(hours=CLEANUP_INTERVAL_HOURS):
                try:
                    os.remove(item_path)
                    count += 1
                except OSError as e:
                    logger.error(f"删除文件失败 {item_path}: {e}")

        logger.info(f"清理完成，共删除 {count} 个文件")
    except Exception as e:
        logger.error(f"清理过程中发生错误: {e}")


def get_download_options(format_type: str, base_filename: str,
                         url: str) -> Dict[str, Any]:
    """
    获取下载选项配置。

    Args:
        format_type: 下载格式类型 ('video' 或 'audio')
        base_filename: 基础文件名
        url: 视频URL

    Returns:
        Dict[str, Any]: yt-dlp 配置选项
    """

    options = {
        'outtmpl':
            os.path.join(DOWNLOAD_DIR, base_filename + '.%(ext)s'),
        'format':
            'bestvideo*+bestaudio/best',
        'progress_hooks': [
            lambda d: logger.info(
                f'下载进度: {d.get("status")}, {d.get("filename", "未知文件名")}')
        ],
    }

    # 添加cookie配置
    cookie_file = get_site_cookies(url)
    if cookie_file:
        options['cookies'] = cookie_file

    return options


@app.route('/download', methods=['GET'])
def download_video() -> Response:
    """
    处理视频下载请求。

    Query Parameters:
        url (required): 要下载的视频URL
        format (optional): 下载格式 ('video' 或 'audio'，默认为 'video')

    Returns:
        Response: 下载的文件或错误信息
    """
    url = request.args.get('url')
    format_type = request.args.get('format',
                                   CONFIG.get('app', {}).get('format', 'video'))

    if not url:
        return jsonify({'error': 'URL parameter is required'}), 400

    if format_type not in ('video', 'audio'):
        return jsonify({'error': 'Invalid format type'}), 400

    try:
        url_hash = hashlib.md5(url.encode()).hexdigest()[:8]
        base_filename = f'video_{url_hash}'

        ydl_opts = get_download_options(format_type, base_filename, url)

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            downloaded_files = glob.glob(
                os.path.join(DOWNLOAD_DIR, base_filename + '.*'))

            if not downloaded_files:
                raise DownloadError('下载完成但未找到文件')

            downloaded_file = downloaded_files[0]
            if not os.path.exists(downloaded_file):
                raise DownloadError(f'下载文件未找到: {downloaded_file}')

            original_title = info.get('title', 'video')
            file_ext = os.path.splitext(downloaded_file)[1]
            safe_title = f"{sanitize_filename(original_title)}{file_ext}"

            # 使用 URL 编码处理文件名
            encoded_title = urllib.parse.quote(safe_title)

            response = send_file(
                downloaded_file,
                as_attachment=True,
                download_name=safe_title,
                mimetype='application/octet-stream')

            response.headers.update({
                'Content-Disposition':
                    f'attachment; filename="{encoded_title}"; filename*=UTF-8\'\'{encoded_title}',
                'X-Filename':
                    encoded_title,
                'X-File-Type':
                    format_type
            })

            return response

    except DownloadError as e:
        logger.error(f"下载错误: {e}")
        return jsonify({'error': str(e)}), 500
    except Exception as e:
        logger.error(f"未预期的错误: {e}")
        return jsonify({'error': '服务器内部错误'}), 500


def init_scheduler() -> None:
    """初始化定时任务调度器"""
    scheduler = BackgroundScheduler()
    scheduler.add_job(cleanup_downloads, 'cron', hour=2, minute=0)
    scheduler.start()
    logger.info("定时清理任务已启动")


def main() -> None:
    """应用程序入口点"""
    try:
        ensure_download_dir()
        init_cookie_files()  # 初始化 cookie 文件
        init_scheduler()
        logger.info(f'服务器将在端口 {PORT} 上启动')
        app.run(host='0.0.0.0', port=PORT)
    except Exception as e:
        logger.error(f'启动服务器时发生错误: {e}')
        raise


if __name__ == '__main__':
    main()
